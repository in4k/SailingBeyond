; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\!!Scene\rw2018\Outside\src\intro.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?musicStarted@@3_NA				; musicStarted
PUBLIC	?font_list_base_2d@@3HA				; font_list_base_2d
PUBLIC	?fparams@@3PAMA					; fparams
PUBLIC	?currentKeyframe@@3HA				; currentKeyframe
PUBLIC	?currentScene@@3HA				; currentScene
PUBLIC	?currentPipeline@@3IA				; currentPipeline
PUBLIC	?currentFrame@@3MA				; currentFrame
_BSS	SEGMENT
?musicStarted@@3_NA DB 01H DUP (?)			; musicStarted
	ALIGN	4

?font_list_base_2d@@3HA DD 01H DUP (?)			; font_list_base_2d
?currentKeyframe@@3HA DD 01H DUP (?)			; currentKeyframe
?currentScene@@3HA DD 01H DUP (?)			; currentScene
?currentPipeline@@3IA DD 01H DUP (?)			; currentPipeline
?currentFrame@@3MA DD 01H DUP (?)			; currentFrame
_BSS	ENDS
CONST	SEGMENT
?timeline@@3QBUkeyframe@@B DD 000000000r	; 0	; timeline
	DD	01H
	DD	00H
	DD	04283a83ar			; 65.8286
	DD	04H
	DD	00H
	DD	042db6db6r			; 109.714
	DD	05H
	DD	00H
	DD	043199999r			; 153.6
	DD	02H
	DD	00H
	DD	0432f8af8r			; 175.543
	DD	03H
	DD	00H
	DD	044000000r			; 512
	DD	01H
	DD	01H
CONST	ENDS
_DATA	SEGMENT
?fparams@@3PAMA DD 000000000r			; 0	; fparams
	DD	044f00000r			; 1920
	DD	044870000r			; 1080
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
_DATA	ENDS
PUBLIC	?intro_init@@YGXXZ				; intro_init
PUBLIC	?intro_pre_init@@YGXXZ				; intro_pre_init
PUBLIC	?intro_do@@YGXM@Z				; intro_do
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@44870000
PUBLIC	__real@44f00000
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__glGenTextures@8:PROC
EXTRN	__imp__glRects@16:PROC
EXTRN	__imp__glTexParameteri@12:PROC
EXTRN	?EXT_Init@@YGHXZ:PROC				; EXT_Init
EXTRN	?myglfunc@@3PAPAXA:BYTE				; myglfunc
EXTRN	?common_init_frag@@3PBDB:DWORD			; common_init_frag
EXTRN	?post_processing_shader_glsl_frag@@3PBDB:DWORD	; post_processing_shader_glsl_frag
EXTRN	?vertex_vert@@3PBDB:DWORD			; vertex_vert
EXTRN	?calc_frag@@3PBDB:DWORD				; calc_frag
EXTRN	?scene1_frag@@3PBDB:DWORD			; scene1_frag
EXTRN	?scene2_frag@@3PBDB:DWORD			; scene2_frag
EXTRN	?scene3_frag@@3PBDB:DWORD			; scene3_frag
EXTRN	?scene4_frag@@3PBDB:DWORD			; scene4_frag
EXTRN	?scene5_frag@@3PBDB:DWORD			; scene5_frag
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?calcShader@@3IA DD 01H DUP (?)				; calcShader
?shaderScene_1@@3IA DD 01H DUP (?)			; shaderScene_1
?shaderScene_2@@3IA DD 01H DUP (?)			; shaderScene_2
?shaderScene_3@@3IA DD 01H DUP (?)			; shaderScene_3
?shaderScene_4@@3IA DD 01H DUP (?)			; shaderScene_4
?shaderScene_5@@3IA DD 01H DUP (?)			; shaderScene_5
?vertexShader@@3IA DD 01H DUP (?)			; vertexShader
?postProcessingShader@@3IA DD 01H DUP (?)		; postProcessingShader
?framebuffer@@3IA DD 01H DUP (?)			; framebuffer
?texture0@@3IA DD 01H DUP (?)				; texture0
?texture1@@3IA DD 01H DUP (?)				; texture1
?texture2@@3IA DD 01H DUP (?)				; texture2
?calcPipeline@@3IA DD 01H DUP (?)			; calcPipeline
?renderPipeline1@@3IA DD 01H DUP (?)			; renderPipeline1
?renderingPipeline2@@3IA DD 01H DUP (?)			; renderingPipeline2
?renderingPipeline3@@3IA DD 01H DUP (?)			; renderingPipeline3
?renderingPipeline4@@3IA DD 01H DUP (?)			; renderingPipeline4
?renderingPipeline5@@3IA DD 01H DUP (?)			; renderingPipeline5
?postProcessingPipeline@@3IA DD 01H DUP (?)		; postProcessingPipeline
_BSS	ENDS
;	COMDAT __real@44f00000
CONST	SEGMENT
__real@44f00000 DD 044f00000r			; 1920
CONST	ENDS
;	COMDAT __real@44870000
CONST	SEGMENT
__real@44870000 DD 044870000r			; 1080
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?drawBuffers@?1??intro_init@@YGXXZ@4QBIB
CONST	SEGMENT
?drawBuffers@?1??intro_init@@YGXXZ@4QBIB DD 08ce0H	; `intro_init'::`2'::drawBuffers
	DD	08ce1H
	DD	08ce2H
CONST	ENDS
; Function compile flags: /Ogspy
; File d:\!!scene\rw2018\outside\src\intro.cpp
;	COMDAT ?intro_do@@YGXM@Z
_TEXT	SEGMENT
_pipelines$ = -24					; size = 24
_time$ = 8						; size = 4
?intro_do@@YGXM@Z PROC					; intro_do, COMDAT

; 435  : {

	sub	esp, 24					; 00000018H

; 436  : 	currentFrame++;

	fld	DWORD PTR ?currentFrame@@3MA		; currentFrame
	fld1

; 437  : 
; 438  : 	float flashIntensity = 0;
; 439  : 	float fade = 1;
; 440  : 	int sceneParam = 0;
; 441  : 	float sceneTime = 1;
; 442  : 
; 443  : 	GLuint pipelines[] = { 0, renderPipeline1, renderingPipeline2, renderingPipeline3, renderingPipeline4, renderingPipeline5 };

	mov	eax, DWORD PTR ?renderingPipeline2@@3IA
	fadd	ST(1), ST(0)
	push	ebx
	mov	DWORD PTR _pipelines$[esp+36], eax
	fxch	ST(1)
	mov	eax, DWORD PTR ?renderingPipeline3@@3IA
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR _pipelines$[esp+44], eax

; 444  : 
; 445  : 	for (int i = 0; i < sizeof(timeline) / sizeof(timeline[0]); i++)

	mov	edx, ebx
	mov	eax, DWORD PTR ?renderingPipeline4@@3IA
	mov	ecx, ebx
	push	esi
	mov	esi, DWORD PTR ?renderPipeline1@@3IA
	fst	DWORD PTR ?currentFrame@@3MA		; currentFrame
	fld	DWORD PTR _time$[esp+32]
	mov	DWORD PTR _pipelines$[esp+52], eax
	mov	eax, DWORD PTR ?renderingPipeline5@@3IA
	push	edi
	mov	DWORD PTR _pipelines$[esp+40], ebx
	mov	DWORD PTR _pipelines$[esp+44], esi
	mov	DWORD PTR _pipelines$[esp+60], eax
$LN4@intro_do:

; 446  : 	{
; 447  : 		if (timeline[i].time < time && timeline[i + 1].time > time)

	fcom	DWORD PTR ?timeline@@3QBUkeyframe@@B[ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@intro_do
	fcom	DWORD PTR ?timeline@@3QBUkeyframe@@B[ecx+12]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN10@intro_do
$LN2@intro_do:
	add	ecx, 12					; 0000000cH

; 444  : 
; 445  : 	for (int i = 0; i < sizeof(timeline) / sizeof(timeline[0]); i++)

	inc	edx
	cmp	ecx, 72					; 00000048H
	jae	SHORT $LN14@intro_do
	jmp	SHORT $LN4@intro_do
$LN10@intro_do:

; 448  : 		{
; 449  : 			currentKeyframe = i;
; 450  : 			currentPipeline = pipelines[timeline[i].pipelineIndex];

	imul	eax, edx, 12
	mov	DWORD PTR ?currentKeyframe@@3HA, edx	; currentKeyframe
	mov	ecx, DWORD PTR ?timeline@@3QBUkeyframe@@B[eax+4]

; 451  : 			currentScene = timeline[i].pipelineIndex;

	mov	DWORD PTR ?currentScene@@3HA, ecx	; currentScene
	mov	eax, DWORD PTR _pipelines$[esp+ecx*4+40]
	mov	DWORD PTR ?currentPipeline@@3IA, eax	; currentPipeline
$LN14@intro_do:

; 452  : 			sceneParam = timeline[i].sceneParam;
; 453  : 			sceneTime = time - timeline[i].time;
; 454  : 			break;
; 455  : 		}
; 456  : 	}
; 457  : 	if (!musicStarted) {

	mov	al, BYTE PTR ?musicStarted@@3_NA	; musicStarted
	test	al, al
	jne	SHORT $LN6@intro_do

; 458  : 		currentPipeline = pipelines[1];

	mov	DWORD PTR ?currentPipeline@@3IA, esi	; currentPipeline
$LN6@intro_do:

; 459  : 	}
; 460  : #ifdef DEBUG
; 461  : 	if (GetAsyncKeyState('1') || GetAsyncKeyState(VK_CONTROL) && GetAsyncKeyState('S'))
; 462  : 	{
; 463  : 		currentPipeline = pipelines[1];
; 464  : 		currentFrame = 0;
; 465  : 	}
; 466  : 
; 467  : 	if (GetAsyncKeyState('2'))
; 468  : 	{
; 469  : 		currentPipeline = pipelines[2];
; 470  : 		
; 471  : 	}
; 472  : 
; 473  : 	if (GetAsyncKeyState('3'))
; 474  : 	{
; 475  : 		currentPipeline = pipelines[3];
; 476  : 	}
; 477  : 
; 478  : 	if (GetAsyncKeyState('4'))
; 479  : 	{
; 480  : 		currentPipeline = pipelines[4];
; 481  : 	}
; 482  : 
; 483  : 	if (GetAsyncKeyState('5'))
; 484  : 	{
; 485  : 		currentPipeline = pipelines[5];
; 486  : 	}
; 487  : //currentPipeline = pipelines[0];
; 488  : 
; 489  : #endif
; 490  : 	//currentPipeline = pipelines[1];
; 491  : 
; 492  : 	/// setup framebufer for rendering to fontTexture
; 493  : 	/// important!
; 494  : 
; 495  : 	// TEXT
; 496  : 	/// clean up and draw font to texture
; 497  : 	/*
; 498  : 	{
; 499  : 	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
; 500  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, fontTexture, 0);
; 501  : 	glBindProgramPipeline(NULL);
; 502  : 	glClear(GL_COLOR_BUFFER_BIT);
; 503  : 	glColor3d(1.0, 1.0, 1.0);
; 504  : 	
; 505  : 		const char texts[9][57] = {
; 506  : 			"                                                        ",
; 507  : 			"                                                        ",
; 508  : 			"          YOU!                          Agenda  Altair  ",
; 509  : 			"   Amnesty    Anadune    Arise    Artstate    Appendix  ",
; 510  : 			"     CrapTeam      Darklite        DMA     Mawi  ",
; 511  : 			"    Elude   EXclusive ON   Floppy   Futuris   Ghostown  ",
; 512  : 			" Lamers   DRRM    Samar    MultiStyle Labs     Plastic  ",
; 513  : 			" Speccy.pl                                              ",
; 514  : 			"                                                        "
; 515  : 		};
; 516  : 		const char texts2[9][57] = {
; 517  : 			"                                                        ",
; 518  : 			"                                                        ",
; 519  : 			"                                     at DECRUNCH 2048   ",
; 520  : 			"                                                        ",
; 521  : 			"     AberrationCreations    +    Eclectique             ",
; 522  : 			"                                                        ",
; 523  : 			"          Digiverse                                     ",
; 524  : 			"                                                        ",
; 525  : 			"                                                        "
; 526  : 
; 527  : 		};
; 528  : 		
; 529  : 		int t = 0;
; 530  : 		for (float i = -1; i < .7; i += .2) {
; 531  : 			glListBase(font_list_base_2d); //start of our font display list numbers
; 532  : 
; 533  : 			if (sceneParam == 24) {
; 534  : 				glRasterPos2f(-.8, i); // set start position
; 535  : 				glCallLists(54, GL_BYTE, &texts2[t++]);
; 536  : 			}
; 537  : 			else {
; 538  : 				glRasterPos2f(-1, i); // set start position
; 539  : 				glCallLists(54, GL_BYTE, &texts[t++]);
; 540  : 			}
; 541  : 			glFlush();
; 542  : 		}
; 543  : 		
; 544  : 
; 545  : 	}
; 546  : 	*/
; 547  : 	///
; 548  : 	/// setup shader arguments
; 549  : 	///
; 550  : 	fparams[0] = time;

	fstp	DWORD PTR ?fparams@@3PAMA

; 551  : 	fparams[1] = XRES;

	fld	DWORD PTR __real@44f00000
	fstp	DWORD PTR ?fparams@@3PAMA+4

; 552  : 	fparams[2] = YRES;

	fld	DWORD PTR __real@44870000
	fstp	DWORD PTR ?fparams@@3PAMA+8

; 553  : 	fparams[3] = currentScene;

	fild	DWORD PTR ?currentScene@@3HA		; currentScene
	fstp	DWORD PTR ?fparams@@3PAMA+12

; 554  : 	fparams[4] = currentFrame;

	fstp	DWORD PTR ?fparams@@3PAMA+16

; 555  : 	fparams[5] = 0.;

	fldz
	fstp	DWORD PTR ?fparams@@3PAMA+20

; 556  : 
; 557  : 	if (!musicStarted) {

	test	al, al
	jne	SHORT $LN25@intro_do

; 558  : 		fparams[5] = 1.;

	fstp	DWORD PTR ?fparams@@3PAMA+20
	jmp	SHORT $LN7@intro_do
$LN25@intro_do:
	fstp	ST(0)
$LN7@intro_do:

; 559  : 	}
; 560  : 
; 561  : #ifdef DEBUG 
; 562  : 
; 563  : #else
; 564  : 	//fparams[4] = Oidos_GetInstrumentTrigger(1, Oidos_GetPosition());
; 565  : #endif
; 566  : 
; 567  : 	/// reset framebufer
; 568  : 	// BindFramebuffer(GL_FRAMEBUFFER, 0);
; 569  : 
; 570  : 	/// render
; 571  : 	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

	push	DWORD PTR ?framebuffer@@3IA
	mov	ebp, 36160				; 00008d40H
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+24

; 572  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texture0, 0);

	push	ebx
	push	DWORD PTR ?texture0@@3IA
	push	36064					; 00008ce0H
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+36

; 573  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, texture1, 0);

	push	ebx
	push	DWORD PTR ?texture1@@3IA
	push	36065					; 00008ce1H
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+36

; 574  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, texture2, 0);

	push	ebx
	push	DWORD PTR ?texture2@@3IA
	push	36066					; 00008ce2H
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+36

; 575  : 
; 576  : 	//glGenerateMipmap(GL_TEXTURE_2D);
; 577  : 
; 578  : 	glProgramUniform4fv(calcShader, 3, 2, fparams);

	mov	ebx, OFFSET ?fparams@@3PAMA		; fparams
	push	ebx
	push	2
	pop	edi
	push	edi
	push	3
	pop	esi
	push	esi
	push	DWORD PTR ?calcShader@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+16

; 579  : 	glProgramUniform4fv(shaderScene_1, 3, 2, fparams);

	push	ebx
	push	edi
	push	esi
	push	DWORD PTR ?shaderScene_1@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+16

; 580  : 	glProgramUniform4fv(shaderScene_2, 3, 2, fparams);

	push	ebx
	push	edi
	push	esi
	push	DWORD PTR ?shaderScene_2@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+16

; 581  : 	glProgramUniform4fv(shaderScene_3, 3, 2, fparams);

	push	ebx
	push	edi
	push	esi
	push	DWORD PTR ?shaderScene_3@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+16

; 582  : 	glProgramUniform4fv(postProcessingShader, 3, 2, fparams);

	push	ebx
	push	edi
	push	esi
	push	DWORD PTR ?postProcessingShader@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+16

; 583  : 
; 584  : 	glBindProgramPipeline(calcPipeline);

	push	DWORD PTR ?calcPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 585  : 	//glActiveTexture(GL_TEXTURE0);
; 586  : 	//glBindTexture(GL_TEXTURE_2D, texture);
; 587  : 	//glEnable(GL_TEXTURE_2D);
; 588  : 	glRects(-1, -1, 1, 1);

	mov	esi, DWORD PTR __imp__glRects@16
	xor	ebx, ebx
	inc	ebx
	or	edi, -1
	push	ebx
	push	ebx
	push	edi
	push	edi
	call	esi

; 589  : 
; 590  : 	glBindProgramPipeline(currentPipeline);	

	push	DWORD PTR ?currentPipeline@@3IA		; currentPipeline
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 591  : 	//glActiveTexture(GL_TEXTURE0);
; 592  : 	//glBindTexture(GL_TEXTURE_2D, texture);
; 593  : 	//glEnable(GL_TEXTURE_2D);
; 594  : 	//glGenerateMipmap(GL_TEXTURE_2D);
; 595  : 	glRects(-1, -1, 1, 1);

	push	ebx
	push	ebx
	push	edi
	push	edi
	call	esi

; 596  : 	//glGenerateMipmap(GL_TEXTURE_2D);
; 597  : 
; 598  : 	///
; 599  : 	/// postprocessing
; 600  : 	///
; 601  : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	push	0
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+24

; 602  : 	glBindProgramPipeline(postProcessingPipeline);

	push	DWORD PTR ?postProcessingPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 603  : 	glRects(-1, -1, 1, 1);

	push	ebx
	push	ebx
	push	edi
	push	edi
	call	esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 604  : 
; 605  : 
; 606  : #ifdef DEBUG 
; 607  : 	
; 608  : 	
; 609  : #endif
; 610  : }

	add	esp, 24					; 00000018H
	ret	4
?intro_do@@YGXM@Z ENDP					; intro_do
_TEXT	ENDS
; Function compile flags: /Ogspy
; File d:\!!scene\rw2018\outside\src\intro.cpp
;	COMDAT ?intro_pre_init@@YGXXZ
_TEXT	SEGMENT
?intro_pre_init@@YGXXZ PROC				; intro_pre_init, COMDAT

; 46   : 	EXT_Init();

	jmp	?EXT_Init@@YGHXZ			; EXT_Init
?intro_pre_init@@YGXXZ ENDP				; intro_pre_init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File d:\!!scene\rw2018\outside\src\intro.cpp
;	COMDAT ?intro_init@@YGXXZ
_TEXT	SEGMENT
_shadersArray$ = -8					; size = 8
?intro_init@@YGXXZ PROC					; intro_init, COMDAT

; 55   : {

	push	ecx
	push	ecx

; 56   : #endif
; 57   : 
; 58   : #ifdef DEBUG
; 59   : 
; 60   : 	static const unsigned long fileReadBufferSize = 1024 * 1024;
; 61   : 	static char fileReadBuffer[fileReadBufferSize];
; 62   : 	static char fileReadBuffer2[fileReadBufferSize];
; 63   : 	unsigned long bytes_read;
; 64   : 	char* commonInit_shaderText;
; 65   : 	char* buffer;
; 66   : 	char* bufferInit;
; 67   : 	HANDLE handle;
; 68   : 
; 69   : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/common_init.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 70   : 	if (handle == INVALID_HANDLE_VALUE) {
; 71   : 		MessageBoxA(nullptr, "../src/shaders/common_init.frag", "/common_init.frag", MB_ICONERROR | MB_OK); return 0;
; 72   : 	}
; 73   : 
; 74   : 	ReadFile(handle, fileReadBuffer2, fileReadBufferSize, &bytes_read, nullptr);
; 75   : 	CloseHandle(handle);
; 76   : 	
; 77   : 	bufferInit = fileReadBuffer2;
; 78   : 	bufferInit[bytes_read] = 0;
; 79   : 	
; 80   : 	
; 81   : 
; 82   : 	const char *shadersArray[2];
; 83   : 	shadersArray[0] = bufferInit;
; 84   : 
; 85   : 	/// first shader
; 86   : 
; 87   : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/calc.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 88   : 	if (handle == INVALID_HANDLE_VALUE) {
; 89   : 		MessageBoxA(nullptr, "../src/shaders/calc.frag", "/calc.frag", MB_ICONERROR | MB_OK); return 0;
; 90   : 	}
; 91   : 
; 92   : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 93   : 	CloseHandle(handle);
; 94   : 
; 95   : 	buffer = fileReadBuffer;
; 96   : 	buffer[bytes_read] = 0;
; 97   : 	shadersArray[1] = buffer;
; 98   : 	calcShader = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);
; 99   : 	//MessageBoxA()
; 100  : 	
; 101  : 	/// second shader
; 102  : 	
; 103  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/scene1.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 104  : 	if (handle == INVALID_HANDLE_VALUE) {
; 105  : 		MessageBoxA(nullptr, "../src/shaders/scene1.frag", "/scene1.frag", MB_ICONERROR | MB_OK); return 0;
; 106  : 	}
; 107  : 
; 108  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 109  : 	CloseHandle(handle);
; 110  : 
; 111  : 	buffer = fileReadBuffer;
; 112  : 	buffer[bytes_read] = 0;
; 113  : 	shadersArray[1] = buffer;
; 114  : 	shaderScene_1 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);
; 115  : 
; 116  : 
; 117  : 
; 118  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/scene2.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 119  : 	if (handle == INVALID_HANDLE_VALUE) {
; 120  : 		MessageBoxA(nullptr, "../src/shaders/scene2.frag", "/scene2.frag", MB_ICONERROR | MB_OK); return 0;
; 121  : 	}
; 122  : 
; 123  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 124  : 	CloseHandle(handle);
; 125  : 
; 126  : 	buffer = fileReadBuffer;
; 127  : 	buffer[bytes_read] = 0;
; 128  : 	shadersArray[1] = buffer;
; 129  : 	shaderScene_2 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);
; 130  : 
; 131  : 
; 132  : 
; 133  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/scene3.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 134  : 	if (handle == INVALID_HANDLE_VALUE) {
; 135  : 		MessageBoxA(nullptr, "../src/shaders/scene3.frag", "/scene3.frag", MB_ICONERROR | MB_OK); return 0;
; 136  : 	}
; 137  : 
; 138  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 139  : 	CloseHandle(handle);
; 140  : 
; 141  : 	buffer = fileReadBuffer;
; 142  : 	buffer[bytes_read] = 0;
; 143  : 	shadersArray[1] = buffer;
; 144  : 	shaderScene_3 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);
; 145  : 
; 146  : 
; 147  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/scene4.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 148  : 	if (handle == INVALID_HANDLE_VALUE) {
; 149  : 		MessageBoxA(nullptr, "../src/shaders/scene4.frag", "/scene4.frag", MB_ICONERROR | MB_OK); return 0;
; 150  : 	}
; 151  : 
; 152  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 153  : 	CloseHandle(handle);
; 154  : 
; 155  : 	buffer = fileReadBuffer;
; 156  : 	buffer[bytes_read] = 0;
; 157  : 	shadersArray[1] = buffer;
; 158  : 	shaderScene_4 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);
; 159  : 
; 160  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/scene5.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 161  : 	if (handle == INVALID_HANDLE_VALUE) {
; 162  : 		MessageBoxA(nullptr, "../src/shaders/scene5.frag", "/scene5.frag", MB_ICONERROR | MB_OK); return 0;
; 163  : 	}
; 164  : 
; 165  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 166  : 	CloseHandle(handle);
; 167  : 
; 168  : 	buffer = fileReadBuffer;
; 169  : 	buffer[bytes_read] = 0;
; 170  : 	shadersArray[1] = buffer;
; 171  : 	shaderScene_5 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);
; 172  : 
; 173  : 	/// vertex
; 174  : 
; 175  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/vertex.vert", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 176  : 	if (handle == INVALID_HANDLE_VALUE) {
; 177  : 		MessageBoxA(nullptr, "../src/shaders/vertex.vert", "/vertex.vert", MB_ICONERROR | MB_OK); return 0;
; 178  : 	}
; 179  : 
; 180  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 181  : 	CloseHandle(handle);
; 182  : 
; 183  : 	buffer = fileReadBuffer;
; 184  : 	buffer[bytes_read] = 0;
; 185  : 
; 186  : 	vertexShader = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, &buffer);
; 187  : 	
; 188  : 	/// postproc
; 189  : 	
; 190  : 	handle = CreateFile("D:/!!Scene/rw2018/Outside/src/shaders/post_processing_shader.glsl.frag", GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
; 191  : 	if (handle == INVALID_HANDLE_VALUE) {
; 192  : 		MessageBoxA(nullptr, "../src/shaders/post_processing_shader.glsl.frag", "/post_processing_shader.glsl.frag", MB_ICONERROR | MB_OK); return 0;
; 193  : 	}
; 194  : 
; 195  : 	ReadFile(handle, fileReadBuffer, fileReadBufferSize, &bytes_read, nullptr);
; 196  : 	CloseHandle(handle);
; 197  : 
; 198  : 	buffer = fileReadBuffer;
; 199  : 	buffer[bytes_read] = 0;
; 200  : 
; 201  : 	postProcessingShader = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, &buffer);
; 202  : 
; 203  : 
; 204  : #else
; 205  : 	const char *shadersArray[2];
; 206  : 	shadersArray[0] = common_init_frag;

	mov	eax, DWORD PTR ?common_init_frag@@3PBDB	; common_init_frag
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _shadersArray$[esp+24], eax

; 207  : 	shadersArray[1] = calc_frag;
; 208  : 	calcShader = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);

	mov	esi, 35632				; 00008b30H
	mov	eax, DWORD PTR ?calc_frag@@3PBDB	; calc_frag
	mov	DWORD PTR _shadersArray$[esp+28], eax
	lea	eax, DWORD PTR _shadersArray$[esp+24]
	push	eax
	push	2
	pop	edi
	push	edi
	push	esi
	call	DWORD PTR ?myglfunc@@3PAPAXA
	mov	DWORD PTR ?calcShader@@3IA, eax

; 209  : 	shadersArray[1] = scene1_frag;

	mov	eax, DWORD PTR ?scene1_frag@@3PBDB	; scene1_frag
	mov	DWORD PTR _shadersArray$[esp+28], eax

; 210  : 	shaderScene_1 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);

	lea	eax, DWORD PTR _shadersArray$[esp+24]
	push	eax
	push	edi
	push	esi
	call	DWORD PTR ?myglfunc@@3PAPAXA
	mov	DWORD PTR ?shaderScene_1@@3IA, eax

; 211  : 	shadersArray[1] = scene2_frag;

	mov	eax, DWORD PTR ?scene2_frag@@3PBDB	; scene2_frag
	mov	DWORD PTR _shadersArray$[esp+28], eax

; 212  : 	shaderScene_2 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);

	lea	eax, DWORD PTR _shadersArray$[esp+24]
	push	eax
	push	edi
	push	esi
	call	DWORD PTR ?myglfunc@@3PAPAXA
	mov	DWORD PTR ?shaderScene_2@@3IA, eax

; 213  : 	shadersArray[1] = scene3_frag;

	mov	eax, DWORD PTR ?scene3_frag@@3PBDB	; scene3_frag
	mov	DWORD PTR _shadersArray$[esp+28], eax

; 214  : 	shaderScene_3 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);

	lea	eax, DWORD PTR _shadersArray$[esp+24]
	push	eax
	push	edi
	push	esi
	call	DWORD PTR ?myglfunc@@3PAPAXA
	mov	DWORD PTR ?shaderScene_3@@3IA, eax

; 215  : 	shadersArray[1] = scene4_frag;

	mov	eax, DWORD PTR ?scene4_frag@@3PBDB	; scene4_frag
	mov	DWORD PTR _shadersArray$[esp+28], eax

; 216  : 	shaderScene_4 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);

	lea	eax, DWORD PTR _shadersArray$[esp+24]
	push	eax
	push	edi
	push	esi
	call	DWORD PTR ?myglfunc@@3PAPAXA
	mov	DWORD PTR ?shaderScene_4@@3IA, eax

; 217  : 	shadersArray[1] = scene5_frag;

	mov	eax, DWORD PTR ?scene5_frag@@3PBDB	; scene5_frag
	mov	DWORD PTR _shadersArray$[esp+28], eax

; 218  : 	shaderScene_5 = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 2, shadersArray);

	lea	eax, DWORD PTR _shadersArray$[esp+24]
	push	eax
	push	edi
	push	esi
	call	DWORD PTR ?myglfunc@@3PAPAXA

; 219  : 	vertexShader = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, &vertex_vert);

	push	OFFSET ?vertex_vert@@3PBDB		; vertex_vert
	xor	ebp, ebp
	mov	DWORD PTR ?shaderScene_5@@3IA, eax
	inc	ebp
	push	ebp
	push	35633					; 00008b31H
	call	DWORD PTR ?myglfunc@@3PAPAXA

; 220  : 
; 221  : 	postProcessingShader = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, &post_processing_shader_glsl_frag);

	push	OFFSET ?post_processing_shader_glsl_frag@@3PBDB ; post_processing_shader_glsl_frag
	push	ebp
	push	esi
	mov	DWORD PTR ?vertexShader@@3IA, eax
	call	DWORD PTR ?myglfunc@@3PAPAXA

; 222  : 
; 223  : #endif
; 224  : 
; 225  : 	glGenProgramPipelines(1, &calcPipeline);

	push	OFFSET ?calcPipeline@@3IA
	push	ebp
	mov	DWORD PTR ?postProcessingShader@@3IA, eax
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 226  : 	glBindProgramPipeline(calcPipeline);

	push	DWORD PTR ?calcPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 227  : 	glUseProgramStages(calcPipeline, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?calcPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 228  : 	glUseProgramStages(calcPipeline, GL_FRAGMENT_SHADER_BIT, calcShader);

	push	DWORD PTR ?calcShader@@3IA
	push	edi
	push	DWORD PTR ?calcPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 229  : 
; 230  : 	glGenProgramPipelines(1, &renderPipeline1);

	push	OFFSET ?renderPipeline1@@3IA
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 231  : 	glBindProgramPipeline(renderPipeline1);

	push	DWORD PTR ?renderPipeline1@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 232  : 	glUseProgramStages(renderPipeline1, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?renderPipeline1@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 233  : 	glUseProgramStages(renderPipeline1, GL_FRAGMENT_SHADER_BIT, shaderScene_1);

	push	DWORD PTR ?shaderScene_1@@3IA
	push	edi
	push	DWORD PTR ?renderPipeline1@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 234  : 
; 235  : 	glGenProgramPipelines(1, &renderingPipeline2);

	push	OFFSET ?renderingPipeline2@@3IA
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 236  : 	glBindProgramPipeline(renderingPipeline2);

	push	DWORD PTR ?renderingPipeline2@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 237  : 	glUseProgramStages(renderingPipeline2, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?renderingPipeline2@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 238  : 	glUseProgramStages(renderingPipeline2, GL_FRAGMENT_SHADER_BIT, shaderScene_2);

	push	DWORD PTR ?shaderScene_2@@3IA
	push	edi
	push	DWORD PTR ?renderingPipeline2@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 239  : 
; 240  : 	glGenProgramPipelines(1, &renderingPipeline3);

	push	OFFSET ?renderingPipeline3@@3IA
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 241  : 	glBindProgramPipeline(renderingPipeline3);

	push	DWORD PTR ?renderingPipeline3@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 242  : 	glUseProgramStages(renderingPipeline3, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?renderingPipeline3@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 243  : 	glUseProgramStages(renderingPipeline3, GL_FRAGMENT_SHADER_BIT, shaderScene_3);

	push	DWORD PTR ?shaderScene_3@@3IA
	push	edi
	push	DWORD PTR ?renderingPipeline3@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 244  : 
; 245  : 	glGenProgramPipelines(1, &renderingPipeline4);

	push	OFFSET ?renderingPipeline4@@3IA
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 246  : 	glBindProgramPipeline(renderingPipeline4);

	push	DWORD PTR ?renderingPipeline4@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 247  : 	glUseProgramStages(renderingPipeline4, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?renderingPipeline4@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 248  : 	glUseProgramStages(renderingPipeline4, GL_FRAGMENT_SHADER_BIT, shaderScene_4);

	push	DWORD PTR ?shaderScene_4@@3IA
	push	edi
	push	DWORD PTR ?renderingPipeline4@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 249  : 
; 250  : 
; 251  : 	glGenProgramPipelines(1, &renderingPipeline5);

	push	OFFSET ?renderingPipeline5@@3IA
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 252  : 	glBindProgramPipeline(renderingPipeline5);

	push	DWORD PTR ?renderingPipeline5@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 253  : 	glUseProgramStages(renderingPipeline5, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?renderingPipeline5@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 254  : 	glUseProgramStages(renderingPipeline5, GL_FRAGMENT_SHADER_BIT, shaderScene_5);

	push	DWORD PTR ?shaderScene_5@@3IA
	push	edi
	push	DWORD PTR ?renderingPipeline5@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 255  : 
; 256  : 	glGenProgramPipelines(1, &postProcessingPipeline);

	push	OFFSET ?postProcessingPipeline@@3IA
	push	ebp
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 257  : 	glBindProgramPipeline(postProcessingPipeline);

	push	DWORD PTR ?postProcessingPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 258  : 	glUseProgramStages(postProcessingPipeline, GL_VERTEX_SHADER_BIT, vertexShader);

	push	DWORD PTR ?vertexShader@@3IA
	push	ebp
	push	DWORD PTR ?postProcessingPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 259  : 	glUseProgramStages(postProcessingPipeline, GL_FRAGMENT_SHADER_BIT, postProcessingShader);

	push	DWORD PTR ?postProcessingShader@@3IA
	push	edi
	push	DWORD PTR ?postProcessingPipeline@@3IA
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 260  : 
; 261  : 
; 262  : #ifdef LOG_ERRORS
; 263  : 	int result;
; 264  : 	char info[1536];
; 265  : 	glGetProgramiv(vertexShader, GL_LINK_STATUS, &result);
; 266  : 	glGetProgramInfoLog(vertexShader, 1024, NULL, (char *)info);
; 267  : 	if (!result) {
; 268  : 		MessageBox(0, info, "Error! vertexShader", MB_OK | MB_ICONEXCLAMATION);
; 269  : 	}
; 270  : 
; 271  : 	glGetProgramiv(calcShader, GL_LINK_STATUS, &result);
; 272  : 	glGetProgramInfoLog(calcShader, 1024, NULL, (char *)info);
; 273  : 	if (!result) {
; 274  : 		MessageBox(0, info, "Error! calcShader", MB_OK | MB_ICONEXCLAMATION);
; 275  : 	}
; 276  : 
; 277  : 	glGetProgramiv(shaderScene_1, GL_LINK_STATUS, &result);
; 278  : 	glGetProgramInfoLog(shaderScene_1, 1024, NULL, (char *)info);
; 279  : 	if (!result) {
; 280  : 		MessageBox(0, info, "Error! shaderScene_1", MB_OK | MB_ICONEXCLAMATION);
; 281  : 	}
; 282  : 
; 283  : 	glGetProgramiv(shaderScene_2, GL_LINK_STATUS, &result);
; 284  : 	glGetProgramInfoLog(shaderScene_2, 1024, NULL, (char *)info);
; 285  : 	if (!result) {
; 286  : 		MessageBox(0, info, "Error! shaderScene_2", MB_OK | MB_ICONEXCLAMATION);
; 287  : 	}
; 288  : 
; 289  : 	glGetProgramiv(shaderScene_3, GL_LINK_STATUS, &result);
; 290  : 	glGetProgramInfoLog(shaderScene_3, 1024, NULL, (char *)info);
; 291  : 	if (!result) {
; 292  : 		MessageBox(0, info, "Error! shaderScene_3", MB_OK | MB_ICONEXCLAMATION);
; 293  : 	}
; 294  : 
; 295  : 	glGetProgramiv(shaderScene_4, GL_LINK_STATUS, &result);
; 296  : 	glGetProgramInfoLog(shaderScene_4, 1024, NULL, (char *)info);
; 297  : 	if (!result) {
; 298  : 		MessageBox(0, info, "Error! shaderScene_4", MB_OK | MB_ICONEXCLAMATION);
; 299  : 	}
; 300  : 
; 301  : 	glGetProgramiv(shaderScene_5, GL_LINK_STATUS, &result);
; 302  : 	glGetProgramInfoLog(shaderScene_5, 1024, NULL, (char *)info);
; 303  : 	if (!result) {
; 304  : 		MessageBox(0, info, "Error! shaderScene_4", MB_OK | MB_ICONEXCLAMATION);
; 305  : 	}
; 306  : 
; 307  : 	glGetProgramiv(postProcessingShader, GL_LINK_STATUS, &result);
; 308  : 	glGetProgramInfoLog(postProcessingShader, 1024, NULL, (char *)info);
; 309  : 	if (!result) {
; 310  : 		MessageBox(0, info, "Error! postProcessingShader", MB_OK | MB_ICONEXCLAMATION);
; 311  : 	}
; 312  : 
; 313  : 	/*
; 314  : 	glGetProgramiv(postProcessingShader2, GL_LINK_STATUS, &result);
; 315  : 	glGetProgramInfoLog(postProcessingShader2, 1024, NULL, (char *)info);
; 316  : 	if (!result) {
; 317  : 		MessageBox(0, info, "Error!", MB_OK | MB_ICONEXCLAMATION);
; 318  : 	}
; 319  : 	*/
; 320  : #endif
; 321  : 
; 322  : 	glGenFramebuffers(4, &framebuffer);

	push	OFFSET ?framebuffer@@3IA
	push	4
	call	DWORD PTR ?myglfunc@@3PAPAXA+20

; 323  : 	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

	push	DWORD PTR ?framebuffer@@3IA
	push	36160					; 00008d40H
	call	DWORD PTR ?myglfunc@@3PAPAXA+24

; 324  : 
; 325  : 	// render
; 326  : 	glGenTextures(1, &texture0);

	mov	edi, DWORD PTR __imp__glGenTextures@8
	push	OFFSET ?texture0@@3IA
	push	ebp
	call	edi

; 327  : 	glActiveTexture(GL_TEXTURE0);

	push	33984					; 000084c0H
	call	DWORD PTR ?myglfunc@@3PAPAXA+40

; 328  : 	glBindTexture(GL_TEXTURE_2D, texture0);

	push	DWORD PTR ?texture0@@3IA
	mov	esi, DWORD PTR __imp__glBindTexture@8
	mov	ebx, 3553				; 00000de1H
	push	ebx
	call	esi

; 329  : 	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, XRES, YRES);

	push	1080					; 00000438H
	push	1920					; 00000780H
	push	34836					; 00008814H
	push	ebp
	push	ebx
	call	DWORD PTR ?myglfunc@@3PAPAXA+28

; 330  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	ebp, 9729				; 00002601H
	push	ebp
	push	10241					; 00002801H
	push	ebx
	mov	ebx, DWORD PTR __imp__glTexParameteri@12
	call	ebx

; 331  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	ebp
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	ebx

; 332  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);

	mov	ebp, 33648				; 00008370H
	push	ebp
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	ebx

; 333  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);

	push	ebp
	mov	ebp, 10243				; 00002803H
	push	ebp
	push	3553					; 00000de1H
	call	ebx

; 334  : 
; 335  : 	//glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
; 336  : 	//glGenerateMipmap(GL_TEXTURE_2D);
; 337  : 
; 338  : 	// main draw
; 339  : 	glGenTextures(1, &texture1);

	push	OFFSET ?texture1@@3IA
	push	1
	call	edi

; 340  : 	glActiveTexture(GL_TEXTURE1);

	push	33985					; 000084c1H
	call	DWORD PTR ?myglfunc@@3PAPAXA+40

; 341  : 	glBindTexture(GL_TEXTURE_2D, texture1);

	push	DWORD PTR ?texture1@@3IA
	push	3553					; 00000de1H
	call	esi

; 342  : 	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, XRES, YRES);

	push	1080					; 00000438H
	push	1920					; 00000780H
	push	34836					; 00008814H
	push	1
	push	3553					; 00000de1H
	call	DWORD PTR ?myglfunc@@3PAPAXA+28

; 343  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	ebx

; 344  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	ebx

; 345  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);

	push	33648					; 00008370H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	ebx

; 346  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);

	push	33648					; 00008370H
	push	ebp
	push	3553					; 00000de1H
	call	ebx

; 347  : 	//glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
; 348  : 
; 349  : 	// calc texture
; 350  : 	glGenTextures(1, &texture2);

	push	OFFSET ?texture2@@3IA
	push	1
	call	edi

; 351  : 	glActiveTexture(GL_TEXTURE2);

	push	33986					; 000084c2H
	call	DWORD PTR ?myglfunc@@3PAPAXA+40

; 352  : 	glBindTexture(GL_TEXTURE_2D, texture2);

	push	DWORD PTR ?texture2@@3IA
	mov	edi, 3553				; 00000de1H
	push	edi
	call	esi

; 353  : 	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, XRES, YRES);

	push	1080					; 00000438H
	push	1920					; 00000780H
	push	34836					; 00008814H
	push	1
	push	edi
	call	DWORD PTR ?myglfunc@@3PAPAXA+28

; 354  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, 9729				; 00002601H
	push	esi
	push	10241					; 00002801H
	push	edi
	call	ebx

; 355  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	esi
	push	10240					; 00002800H
	push	edi
	call	ebx

; 356  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);

	mov	esi, 33648				; 00008370H
	push	esi
	push	10242					; 00002802H
	push	edi
	call	ebx

; 357  : 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);

	push	esi
	push	ebp
	push	edi
	call	ebx

; 358  : 
; 359  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texture0, 0);

	xor	esi, esi
	mov	edi, 36160				; 00008d40H
	push	esi
	push	DWORD PTR ?texture0@@3IA
	push	36064					; 00008ce0H
	push	edi
	call	DWORD PTR ?myglfunc@@3PAPAXA+36

; 360  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, texture1, 0);

	push	esi
	push	DWORD PTR ?texture1@@3IA
	push	36065					; 00008ce1H
	push	edi
	call	DWORD PTR ?myglfunc@@3PAPAXA+36

; 361  : 	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, texture2, 0);

	push	esi
	push	DWORD PTR ?texture2@@3IA
	push	36066					; 00008ce2H
	push	edi
	call	DWORD PTR ?myglfunc@@3PAPAXA+36

; 362  : 
; 363  : 	static const GLenum drawBuffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2 };
; 364  : 	//
; 365  : 	glDrawBuffers(3, drawBuffers);

	push	OFFSET ?drawBuffers@?1??intro_init@@YGXXZ@4QBIB
	push	3
	call	DWORD PTR ?myglfunc@@3PAPAXA+32
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 366  : 
; 367  : #ifdef DEBUG
; 368  : 	return 1;
; 369  : #endif // DEBUG
; 370  : 
; 371  : }

	pop	ecx
	pop	ecx
	ret	0
?intro_init@@YGXXZ ENDP					; intro_init
_TEXT	ENDS
END
